using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace WpfApp1.ViewModel
{
    /// <summary>
    /// Класс Notifier реализует интерфейс INotifyPropertyChanged и
    /// будет использоваться в модели и модели-представлении для уведомлений об изменениях.
    /// Фактически он является оболочкой для инкапсуляции INotifyPropertyChanged.
    /// </summary>
    public abstract class Notifier : INotifyPropertyChanged
    {
        /// <summary>
        /// Вызывается, когда свойство этого объекта приобретает новое значение.
        /// </summary>
        public event PropertyChangedEventHandler PropertyChanged;

        /// <summary>
        /// Вызывает событие PropertyChanged этого объекта.
        /// </summary>
        /// <param name="propertyName">Свойство, имеющее новое значение.</param>
        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
        /// <summary>
        /// Проверяет, соответствует ли свойство требуемому значению. 
        /// Устанавливает свойство и уведомляет слушателей только при необходимости.
        /// </summary>
        /// <typeparam name="T">Тип свойства.</typeparam>
        /// <param name="storage">Ссылка на свойства как с геттера, так и с сеттера</param>
        /// <param name="value">Желаемое значение для свойства.</param>
        /// <param name="propertyName">Имя свойства, используемого для уведомления слушателей. 
        /// Это значение необязательно и может быть предоставлено автоматически при вызове из компиляторов, 
        /// поддерживающих CallerMemberName.</param>
        /// <returns>True, если значение было изменено, и false, если существующее значение соответствовало
        /// желаемому значению.</returns>
        protected virtual bool SetProperty<T>(ref T storage, T value, [CallerMemberName] string propertyName = "")
        {
            if (EqualityComparer<T>.Default.Equals(storage, value))
                return false;
            storage = value;
            this.OnPropertyChanged(propertyName);
            return true;
        }
    }

    #region Комментарии
    //Шаблон MVVM помогает четко отделить бизнес-логику приложения и логику представления от его пользовательского интерфейса(UI).
    // Четкое разделение логики приложения и пользовательского интерфейса помогает решить многочисленные проблемы разработки
    // и упрощает тестирование, поддержку и развитие приложения.

    // Помимо понимания обязанностей каждого компонента, также важно понимать, как они взаимодействуют.
    // На высоком уровне представление "знает о" модели представления, а модель представления "знает о" модели,
    // но модель не знает о модели представления, а модель представления не знает о представлении.
    // Таким образом, модель представления изолирует представление от модели и позволяет модели развиваться независимо от представления.

    // ViewModel
    // Модель представления реализует свойства и команды, к которым представление может привязывать данные,
    // и уведомляет представление о любых изменениях состояния посредством событий уведомления об изменениях.

    // Свойства и команды, предоставляемые моделью представления, определяют функциональность,
    // которая будет предлагаться пользовательским интерфейсом, но представление определяет,
    // как эта функциональность должна отображаться.

    // Для того, чтобы модель представления участвовала в двусторонней привязке данных к представлению,
    // ее свойства должны вызывать PropertyChanged событие.
    // Модели представлений удовлетворяют этому требованию, реализуя INotifyPropertyChanged интерфейс
    // и вызывая PropertyChanged событие при изменении свойства.

    // Для коллекций предоставляется удобный для просмотра формат ObservableCollection<T>.
    // В этой коллекции реализовано уведомление об изменении коллекции,
    // освобождающее разработчика от необходимости реализовывать INotifyCollectionChanged интерфейс для коллекций.



    // INotifyPropertyChanged cообщает клиенту об изменении значения свойства.
    // При реализации этот интерфейс сообщает связанному элементу управления об изменениях свойств бизнес-объекта.
    // Привязка данных — это процесс установки соединения между пользовательским интерфейсом и отображаемыми данными.
    // Если для привязки заданы правильные настройки, а изменения значений данных сопровождаются правильными уведомлениями,
    // привязанные к данным элементы автоматически отражают изменения.


    // С помощью информационных атрибутов можно получить сведения о вызывающем объекте метода.
    // [CallerMemberName] позволяет получить имя свойства или метода вызывающего метод объекта.
    // https://learn.microsoft.com/ru-ru/dotnet/api/system.runtime.compilerservices.callermembernameattribute?view=net-8.0
    // При использовании атрибута CallerMemberName в вызовах метода OnPropertyChanged
    // нет необходимости указывать имя свойства в качестве строкового аргумента.



    // Метод SetProperty просто запускает PropertyChanged событие, когда значение свойства изменяется, и возвращает true. 
    // Он не запускает событие, если значение не изменилось, и возвращает false. 
    // Основная идея заключается в том, что SetProperty метод является виртуальным,
    // и вы можете расширить его в более конкретном классе, например, для запуска проверки или путем вызова PropertyChanging события.



    #endregion
}
